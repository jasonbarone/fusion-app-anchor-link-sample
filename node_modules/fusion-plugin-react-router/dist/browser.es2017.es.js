import { createElement, Component, Children } from 'react';
import PropTypes from 'prop-types';
import { Router, Route, BrowserRouter, HashRouter, Link, MemoryRouter, NavLink, Prompt, Switch, matchPath, withRouter } from 'react-router-dom';
import createBrowserHistory from 'history/createBrowserHistory';
import { UniversalEventsToken } from 'fusion-plugin-universal-events';
import { createPlugin, createToken, unescape, memoize } from 'fusion-core';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class Status extends Component {
  constructor(props, context) {
    super(props, context);
    const {
      router: {
        staticContext
      }
    } = context;

    if (staticContext && staticContext.setCode) {
      staticContext.setCode(parseInt(this.props.code, 10));
    }
  }

  render() {
    const children = this.props && this.props.children;
    return Array.isArray(children) ? children[0] : children;
  }

}
Status.contextTypes = {
  router: PropTypes.shape({
    staticContext: PropTypes.object
  })
};
const NotFound = props => createElement(Status, {
  code: 404
}, props.children);

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class Redirect extends Component {
  constructor(props, context) {
    super(props, context);
    if (this.isStatic(context)) this.perform();
  }

  componentDidMount() {
    if (!this.isStatic()) this.perform();
  }

  isStatic(context = this.context) {
    return !!(context && context.router && context.router.staticContext);
  }

  perform() {
    const {
      history,
      staticContext
    } = this.context.router;
    const {
      push,
      to,
      code
    } = this.props;

    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  }

  render() {
    return null;
  }

}
Redirect.defaultProps = {
  push: false,
  code: 307
};
Redirect.contextTypes = {
  router: PropTypes.shape({
    history: PropTypes.shape({
      push: PropTypes.func.isRequired,
      replace: PropTypes.func.isRequired
    }).isRequired,
    staticContext: PropTypes.object
  }).isRequired
}; // Sanity type checking

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const ReactRouterRoute = Route;

const isEmptyChildren = children => Children.count(children) === 0;

function Route$1(props, context) {
  const {
    trackingId,
    component,
    render,
    children
  } = props,
        remainingProps = _objectWithoutProperties(props, ["trackingId", "component", "render", "children"]);

  return createElement(ReactRouterRoute, _extends({}, remainingProps, {
    // eslint-disable-next-line react/no-children-prop
    children: routeProps => {
      const {
        match
      } = routeProps;

      if (match && match.isExact) {
        context.onRoute({
          page: match.path,
          title: trackingId || match.path,
          params: match.params
        });
      }

      if (component) return match ? createElement(component, routeProps) : null;
      if (render) return match ? render(routeProps) : null;
      if (typeof children === 'function') return children(routeProps);
      if (children && !isEmptyChildren(children)) return Children.only(children);
      return null;
    }
  }));
}

Route$1.contextTypes = {
  onRoute: PropTypes.func.isRequired
};
Route$1.displayName = 'FusionRoute';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const BaseRouter$1 = Router;

class BrowserRouter$2 extends Component {
  constructor(props, context) {
    super(props, context);
    this.lastTitle = null;
  }

  getChildContext() {
    const {
      __IS_PREPARE__
    } = this.context;
    return {
      onRoute: routeData => {
        if (routeData.title !== this.lastTitle && !__IS_PREPARE__) {
          this.lastTitle = routeData.title;
          this.props.onRoute && this.props.onRoute(routeData);
        }
      }
    };
  }

  render() {
    const {
      Provider,
      history,
      basename
    } = this.props;
    if (!Provider) throw new Error('Missing Provider for Browser Router');
    return createElement(Provider, {
      basename: basename,
      history: history
    }, this.props.children);
  }

}

BrowserRouter$2.defaultProps = {
  onRoute: () => {},
  Provider: BaseRouter$1
};
BrowserRouter$2.propTypes = {
  children: PropTypes.node,
  onRoute: PropTypes.func,
  history: PropTypes.object,
  Provider: PropTypes.any,
  basename: PropTypes.string
};
BrowserRouter$2.contextTypes = {
  __IS_PREPARE__: PropTypes.bool
};
BrowserRouter$2.childContextTypes = {
  onRoute: PropTypes.func.isRequired
};
const BrowserRouterTyped = BrowserRouter$2;

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
/**
 * Cast each of these imports from react-router-dom to a copied-version of their
 * types.  This is necessary as the libdef defined types will not be accessible to
 * consumers of this package.
 */
const BrowserRouter$3 = BrowserRouter;
const HashRouter$2 = HashRouter;
const Link$2 = Link;
const MemoryRouter$2 = MemoryRouter;
const NavLink$2 = NavLink;
const Prompt$2 = Prompt;
const Switch$2 = Switch;
const matchPath$2 = matchPath;
const withRouter$2 = withRouter;

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const RouterProviderToken = createToken('RouterProvider');
const RouterToken = createToken('Router');
const Router$1 = BrowserRouterTyped;
const plugin = createPlugin({
  deps: {
    emitter: UniversalEventsToken.optional,
    Provider: RouterProviderToken.optional
  },
  middleware: ({
    emitter,
    Provider = Router
  }, self) => {
    return async (ctx, next) => {
      const prefix = ctx.prefix || '';

      if (!ctx.element) {
        return next();
      }

      const myAPI = self.from(ctx);

      {
        // TODO(#3): We should consider adding render/downstream/upstream timings for the browser
        let pageData = {};
        const element = document.getElementById('__ROUTER_DATA__');

        if (element) {
          pageData = JSON.parse(unescape(element.textContent));
        }

        emitter && emitter.map(payload => {
          if (payload && typeof payload === 'object') {
            payload.__url__ = pageData.title;
            payload.__urlParams__ = pageData.params;
          }

          return payload;
        }); // Expose the history object

        const history = createBrowserHistory({
          basename: ctx.prefix
        });
        myAPI.history = history;
        ctx.element = createElement(Router$1, {
          history: history,
          Provider: Provider,
          basename: ctx.prefix,
          onRoute: payload => {
            pageData = payload;
            emitter && emitter.emit('pageview:browser', payload);
          }
        }, ctx.element);
        return next();
      }
    };
  },

  provides() {
    return {
      from: memoize(() => {
        const api = {
          history: null
        };
        return api;
      })
    };
  }

});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const BrowserRouter$4 = BrowserRouter$3;
const HashRouter$3 = HashRouter$2;
const Link$3 = Link$2;
const matchPath$3 = matchPath$2;
const MemoryRouter$3 = MemoryRouter$2;
const NavLink$3 = NavLink$2;
const Prompt$3 = Prompt$2;
const Route$2 = Route$1;
const Router$2 = BrowserRouterTyped;
const Switch$3 = Switch$2;
const withRouter$3 = withRouter$2;
const NotFound$1 = NotFound;
const Redirect$1 = Redirect;
const Status$1 = Status;

export default plugin;
export { BrowserRouter$4 as BrowserRouter, HashRouter$3 as HashRouter, Link$3 as Link, matchPath$3 as matchPath, MemoryRouter$3 as MemoryRouter, NavLink$3 as NavLink, NotFound$1 as NotFound, Prompt$3 as Prompt, Redirect$1 as Redirect, Route$2 as Route, Router$2 as Router, Status$1 as Status, Switch$3 as Switch, withRouter$3 as withRouter, RouterProviderToken, RouterToken };
//# sourceMappingURL=browser.es2017.es.js.map
