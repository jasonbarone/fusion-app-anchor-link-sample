import * as React from 'react';
import { isValidElement, createElement, Component, Children, createContext } from 'react';
import PropTypes from 'prop-types';
import { isFragment, isContextConsumer, isContextProvider, isForwardRef, isPortal } from 'react-is';
import FusionApp, { createPlugin, CriticalChunkIdsToken } from 'fusion-core';
import { renderToString } from 'react-dom/server';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const REACT_PREPARE = '@__REACT_PREPARE__@';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const prepared = (sideEffect, opts = {}) => OriginalComponent => {
  opts = Object.assign({
    boundary: false,
    defer: false,
    componentDidMount: true,
    componentWillReceiveProps: false,
    componentDidUpdate: false,
    contextTypes: {},
    forceUpdate: false
  }, opts);
  const prep = {
    prepare: (...args) => Promise.resolve(sideEffect(...args)),
    defer: opts.defer
  }; // Disable eslint for deprecated componentWillReceiveProps
  // eslint-disable-next-line react/no-deprecated

  class PreparedComponent extends Component {
    // $FlowFixMe
    constructor(props, context) {
      super(props, context); // $FlowFixMe

      this[REACT_PREPARE] = prep;
    }

    componentDidMount() {
      if (opts.componentDidMount) {
        Promise.resolve(sideEffect(this.props, this.context)).then(() => {
          if (opts.forceUpdate) {
            this.forceUpdate();
          }
        });
      }
    } // $FlowFixMe


    UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
      if (opts.componentWillReceiveProps) {
        sideEffect(nextProps, nextContext);
      }
    }

    componentDidUpdate() {
      if (opts.componentDidUpdate) {
        sideEffect(this.props, this.context);
      }
    }

    render() {
      return createElement(OriginalComponent, this.props);
    }

  }

  const displayName = OriginalComponent.displayName || OriginalComponent.name || '';
  PreparedComponent.contextTypes = opts.contextTypes;
  PreparedComponent.displayName = `PreparedComponent(${displayName})`;
  return PreparedComponent;
}; // $FlowFixMe


function isPrepared(CustomComponent) {
  return CustomComponent[REACT_PREPARE] && typeof CustomComponent[REACT_PREPARE].prepare === 'function';
} // $FlowFixMe


function getPrepare(CustomComponent) {
  return CustomComponent[REACT_PREPARE] || {};
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const storeShape = PropTypes.shape({
  dispatch: PropTypes.func.isRequired
}); // $FlowFixMe

const dispatched = (prepareUsingDispatch, opts = {}) => OriginalComponent => {
  const prepare = (props, context) => {
    return prepareUsingDispatch(props, context.store.dispatch);
  };

  const contextTypes = Object.assign({}, opts && opts.contextTypes ? opts.contextTypes : {}, {
    store: storeShape
  });
  const preparedOpts = Object.assign({}, opts, {
    contextTypes
  });
  return prepared(prepare, preparedOpts)(OriginalComponent);
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function isReactCompositeComponent(type) {
  if (type != null && type instanceof Function && type.prototype != null && typeof type.prototype.render === 'function') {
    return true;
  }

  return false;
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function isReactFunctionalComponent(type) {
  if (type instanceof Function && (type.prototype == null || !type.prototype.render)) return true;
  return false;
}

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function renderCompositeElementInstance(instance) {
  const childContext = Object.assign({}, instance.context, instance.getChildContext ? instance.getChildContext() : {});

  if (instance.constructor && instance.constructor.getDerivedStateFromProps) {
    instance.state = _objectSpread({}, instance.state, instance.constructor.getDerivedStateFromProps(instance.props, instance.state));
  } else {
    // see https://github.com/reactjs/react-lifecycles-compat/blob/0a02b805fcf119128d1a9244e71ea7077e2cdcc0/index.js#L114
    if (instance.componentWillMount) {
      instance.componentWillMount();
    } else if (instance.UNSAFE_componentWillMount) {
      instance.UNSAFE_componentWillMount();
    }
  }

  const children = instance.render();
  return [children, childContext];
}

function prepareComponentInstance(instance) {
  if (!isPrepared(instance)) {
    return Promise.resolve({});
  }

  const prepareConfig = getPrepare(instance); // If the component is deferred, skip the prepare step

  if (prepareConfig.defer) {
    return Promise.resolve(prepareConfig);
  } // $FlowFixMe


  return prepareConfig.prepare(instance.props, instance.context).then(() => {
    return prepareConfig;
  });
}

function prepareElement(element, context) {
  if (element === null || typeof element !== 'object') {
    return Promise.resolve([null, context]);
  }

  const {
    type,
    props
  } = element;

  if (isContextConsumer(element)) {
    return Promise.resolve([props.children(type._currentValue), context]);
  }

  if (isContextProvider(element)) {
    type._context._currentValue = props.value;
    return Promise.resolve([props.children, context]);
  }

  if (typeof type === 'string' || isFragment(element) || isForwardRef(element)) {
    return Promise.resolve([props.children, context]);
  } else if (isReactFunctionalComponent(type)) {
    return Promise.resolve([type(props, context), context]);
  } else if (isReactCompositeComponent(type)) {
    const CompositeComponent = type;
    const instance = new CompositeComponent(props, context);
    instance.props = props;
    instance.context = context;
    return prepareComponentInstance(instance).then(prepareConfig => {
      // Stop traversing if the component is defer or boundary
      if (prepareConfig.defer || prepareConfig.boundary) {
        return Promise.resolve([null, context]);
      }

      return renderCompositeElementInstance(instance);
    });
  } else if (isPortal(element)) {
    return Promise.resolve([element.children, context]);
  } else {
    throw new TypeError(`Invalid React element type. Must be a string, a function or a subclass of React.Component. ` + `This error happens if you write a React Component <Foo> where Foo is undefined. ` + `This can happen when mistakenly using a default import instead of a named import or vice-versa, ` + `or if you are missing a peerDependency in your package.json and your package manager hoists an older version from an unrelated dependency \n\n` + JSON.stringify(element, null, 2));
  }
}

function _prepare(element, context) {
  return prepareElement(element, context).then(([children, childContext]) => {
    return Promise.all(Children.toArray(children).map(child => _prepare(child, childContext)));
  });
}

function prepare(element, context = {}) {
  context.__IS_PREPARE__ = true;
  return _prepare(element, context).then(() => {
    context.__IS_PREPARE__ = false;
  });
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const CHUNKS_KEY = '__CHUNK_IDS';
const contextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired
};

{
  // $FlowFixMe
  contextTypes.markAsCritical = PropTypes.func;
} // $FlowFixMe


function withAsyncComponent({
  defer,
  load,
  LoadingComponent,
  ErrorComponent
}) {
  let AsyncComponent = null;
  let error = null;
  let chunkIds = [];

  function WithAsyncComponent(props) {
    if (error) {
      return createElement(ErrorComponent, {
        error: error
      });
    }

    if (!AsyncComponent) {
      return createElement(LoadingComponent, null);
    }

    return createElement(AsyncComponent, props);
  }

  return prepared((props, context) => {
    if (AsyncComponent) {
      if (true && context.markAsCritical) {
        chunkIds.forEach(chunkId => {
          context.markAsCritical(chunkId);
        });
      }

      return Promise.resolve(AsyncComponent);
    }

    let componentPromise;

    try {
      componentPromise = load();
    } catch (e) {
      componentPromise = Promise.reject(e);
    } // $FlowFixMe


    chunkIds = componentPromise[CHUNKS_KEY] || [];

    if (true && context.markAsCritical) {
      chunkIds.forEach(chunkId => {
        context.markAsCritical(chunkId);
      });
    }

    const loadPromises = [componentPromise, ...context.splitComponentLoaders.map(loader => loader(chunkIds))];
    return Promise.all(loadPromises).then(([asyncComponent]) => {
      // Note: .default is toolchain specific, breaks w/ CommonJS exports
      AsyncComponent = asyncComponent.default;

      if (AsyncComponent === undefined) {
        throw new Error('Bundle does not contain a default export');
      }
    }).catch(err => {
      error = err;
       // log error
    });
  }, {
    defer,
    contextTypes,
    forceUpdate: true
  })(WithAsyncComponent);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// to visit the minimum number of nodes

var exclude = prepared(Promise.resolve(), {
  componentDidMount: false,
  componentWillReceiveProps: false,
  componentDidUpdate: false,
  defer: true
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class PrepareProvider extends Component {
  constructor(props, context) {
    super(props, context);
    this.splitComponentLoaders = [];
    this.markAsCritical = props.markAsCritical;
  }

  getChildContext() {
    return {
      splitComponentLoaders: this.splitComponentLoaders,
      markAsCritical: this.markAsCritical
    };
  }

  render() {
    return Children.only(this.props.children);
  }

}

PrepareProvider.childContextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired,
  markAsCritical: PropTypes.func
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const middleware = function (ctx, next) {
  if (process.env.NODE_ENV !== "production") {
    // eslint-disable-next-line no-console
    console.warn('The {middleware} export from fusion-react is deprecated.');
  }

  if (true && !ctx.element) {
    return next();
  }

  const markAsCritical = chunkId => {
    // Push to legacy context for backwards compat w/ legacy SSR template
    ctx.preloadChunks.push(chunkId);
  };
  ctx.element = createElement(PrepareProvider, {
    markAsCritical: markAsCritical
  }, ctx.element);
  return next();
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const prepareTyped = prepare;
const preparedTyped = prepared;
const splitTyped = withAsyncComponent;
const excludeTyped = exclude;

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } return target; }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// React.createContext ponyfill
function createContext$1(value) {
  if ('createContext' in React) {
    return createContext(value);
  }

  const key = `_fusionContextPonyfill${Math.random()}`;

  class Provider extends Component {
    getChildContext() {
      return {
        [key]: this.props.value || value
      };
    }

    render() {
      return this.props.children;
    }

  }

  Provider.childContextTypes = {
    [key]: PropTypes.any.isRequired
  };

  function Consumer(props, context) {
    return props.children(context[key]);
  }

  Consumer.contextTypes = {
    [key]: PropTypes.any.isRequired
  };
  return {
    Provider,
    Consumer
  };
}

let InjectorContext;

function getServices(app, deps) {
  const services = {};
  Object.entries(deps).forEach(([name, token]) => {
    // To be addressed in a future Flow-focued PR.
    // $FlowFixMe
    services[name] = app.getService(token);
  });
  return services;
} // istanbul ignore next


function defaultInject(deps) {
  return {};
}

function defaultMap(services) {
  return services;
}

function registerInjector(app) {
  // Lazily create context for easier testing
  InjectorContext = createContext$1(defaultInject);

  function inject(deps) {
    return getServices(app, deps);
  }

  function renderProvider(children) {
    return createElement(InjectorContext.Provider, {
      value: inject
    }, children);
  }

  const injectorPlugin = createPlugin({
    middleware: () => (ctx, next) => {
      ctx.element = ctx.element && renderProvider(ctx.element);
      return next();
    }
  });
  app.register(injectorPlugin);
}
function withServices(deps, mapServicesToProps = defaultMap) {
  function resolve(inject, props) {
    const services = inject(deps);
    const serviceProps = mapServicesToProps(services);
    return _objectSpread$1({}, serviceProps, props);
  }

  function renderConsumer(Component$$1, props) {
    return createElement(InjectorContext.Consumer, null, inject => createElement(Component$$1, resolve(inject, props)));
  }

  return Component$$1 => {
    return function WithServices(props) {
      return renderConsumer(Component$$1, props);
    };
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */
var serverRender = (el => `<div id='root'>${renderToString(el)}</div>`);

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } return target; }

function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Provider = {
  create: name => {
    class Provider extends Component {
      getChildContext() {
        return {
          [name]: this.props.provides
        };
      }

      render() {
        return Children.only(this.props.children);
      }

    }

    Provider.childContextTypes = _objectSpread$2({}, Provider.childContextTypes || {}, {
      [name]: PropTypes.any.isRequired
    });
    Provider.displayName = name.replace(/^./, c => c.toUpperCase()) + 'Provider';
    return Provider;
  }
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var plugin = {
  create: (name, plugin, provider) => {
    if (plugin.__plugin__ === undefined) {
      plugin = createPlugin(plugin);
    }

    if (!plugin.__plugin__) {
      throw new Error('Provided plugin does not match FusionPlugin<TDeps, TService>');
    }

    let originalMiddleware = plugin.middleware;
    const ProviderComponent = provider || Provider.create(name);

    plugin.middleware = (deps, provides) => {
      let nextMiddleware = originalMiddleware && originalMiddleware(deps, provides);

      const mw = function (ctx, next) {
        if (ctx.element) {
          ctx.element = createElement(ProviderComponent, {
            provides,
            ctx
          }, ctx.element);
        }

        if (nextMiddleware) {
          return nextMiddleware(ctx, next);
        }

        return next();
      };

      return mw;
    };

    return plugin;
  }
};

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$3(target, key, source[key]); }); } return target; }

function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var hoc = {
  create: (name, mapProvidesToProps) => {
    const mapProvides = mapProvidesToProps ? mapProvidesToProps : provides => ({
      [name]: provides
    });
    return Component$$1 => {
      class HOC extends Component {
        constructor(props, ctx) {
          super(props, ctx);
          this.provides = ctx[name];
        }

        render() {
          const props = _objectSpread$3({}, this.props, mapProvides(this.provides));

          return createElement(Component$$1, props);
        }

      }

      const displayName = Component$$1.displayName || Component$$1.name || 'Anonymous';
      HOC.displayName = 'With' + name.replace(/^./, c => c.toUpperCase()) + '(' + displayName + ')';
      HOC.contextTypes = {
        [name]: PropTypes.any.isRequired
      };
      return HOC;
    };
  }
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
class App extends FusionApp {
  constructor(root, render) {
    if (!isValidElement(root)) throw new Error('Invalid React element. Ensure your root element is a React.Element (e.g. <Foo />) and not a React.Component (e.g. Foo)');
    const renderer = createPlugin({
      deps: {
        criticalChunkIds: CriticalChunkIdsToken.optional
      },

      provides() {
        return el => {
          return prepareTyped(el).then(() => {
            if (render) {
              return render(el);
            }

            return serverRender(el);
          });
        };
      },

      middleware({
        criticalChunkIds
      }) {
        return (ctx, next) => {
          if (true && !ctx.element) {
            return next();
          }

          const markAsCritical = chunkId => {
            // Push to legacy context for backwards compat w/ legacy SSR template
            ctx.preloadChunks.push(chunkId); // Also use new service if registered

            if (criticalChunkIds) {
              let chunkIds = criticalChunkIds.from(ctx);
              chunkIds.add(chunkId);
            }
          };
          ctx.element = createElement(PrepareProvider, {
            markAsCritical: markAsCritical
          }, ctx.element);
          return next();
        };
      }

    });
    super(root, renderer);
    registerInjector(this);
  }

}

export default App;
export { plugin as ProviderPlugin, hoc as ProvidedHOC, Provider, withServices, dispatched, prepareTyped as prepare, preparedTyped as prepared, splitTyped as split, excludeTyped as exclude, middleware };
//# sourceMappingURL=index.es.js.map
